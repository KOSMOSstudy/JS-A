# 9주차 JS 스터디 정리

| 장   | 제목                   |
| ---- | ---------------------- |
| 11장 | 노드 서비스 테스트하기 |

## 11장

### 11.1 테스트 준비하기

jest: 페이스북에서 만든 오픈 소스: 테스팅에 필요한 툴을 대부분 갖추고 있어 편리

> npm test: 테스트를 아무것도 작성하지 않아 에러 발생: 테스트 실패

- test 함수(테스트에 대한 설명, 테스트의 내용)
- expect 함수(실제코드)
- toEqual(인수로 예상되는 결과값)

if) expect 값 = toEqual 값: 테스트 통과

if) 테스트 실패하면 어떤 부분에서 실패했는지 시각적으로 보여줘

### 11.2 유닛 테스트

: 작은 단위의 함수나 모듈이 의도된 대로 정확히 작동하는지 테스트(= 단위 테스트)

→ 나중에 함수를 수정하면 기존에 작성해둔 테스트 = 실패

→ 함수가 수정되었을 때 어떤 부분이 고장나는지를 테스트 통해 알 수 있음

→ 테스트 코드도 기존 코드가 변경된 것에만 맞춰서 수정

**[middlewares.test.js]**

- describe함수: 테스트를 그룹화하는 역할
  - describe(그룹에 대한 설명, 그룹에 대한 내용) = test 함수

익스프레스가 req, res 객체와 next 함수를 인수로 넣어서 성공 but 테스트 환경에서는?

⇒ 가짜 객체와 함수를 만들어 넣으면 됨 = 모킹(mocking)

- isLoggedIn 함수: req, res, next 모킹, 함수 모킹 시 jest.fn 메서드 사용
  - 함수의 반환 값 지정 = jest.fn(() ⇒ 반환값) 사용
- isAuthenticated 함수: 로그인 여부 알려주는 함수, test 내용에 따라 true나 false 리턴
- res.status = 메서드 체이닝이 가능해야하기 때문에 res 반환 ex) res.status(403).send('hello')
- toBeCalledTimes(숫자): 정확하게 몇 번 호출되었는지를 체크하는 메서드
- toBeCalledWith(인수): 특정 인수와 함께 호출되었는지를 체크하는 메서드

**[user.test.js]**

- jest.mock 메서드: 모킹할 모듈의 경로를 인수, 그 모듈을 불러옴

1. mockReturnValue 메서드 → User.findOne이 {addFollowing()} 객체 반환하도록 → 사용자 찾아서 팔로잉 추가하는 상황을 테스트 하기 위해, 프로미스 반환해야 다음에 await user.addFollowing 메서드 추가 가능

2. null 반환하여 사용자 찾지 못한 상황 테스트

3. Promise.reject로 에러 발생하도록, DB 연결에 에러 발생한 상황을 모킹

### 11.3 테스트 커버리지

: 전체 코드 중 테스트되고 있는 코드의 비율과 테스트되고 있지 않은 코드의 위치를 알려주는 jest의 기능

> npm run coverage: 테스트 결과 출력, 표가 하나 더 출력

: File(파일과 폴더 이름), % Stmts(구문 비율), % Branch(if문 등의 분기점 비율), % Func(함수 비율), % Lines(코드 줄 수 비율), Uncovered Lins #s(커버되지 않은 줄 위치) ⇒ %가 높을 수록 많은 코드 테스트

⇒ 명시적으로 테스트하고 require한 코드만 커버리지 분석이 된다 = 100%여도 실제로 모든 코드를 테스트한 것은 아닐 수 있음

### 11.4 통합 테스트

: 하나의 라우터에는 여러 개의 미들웨어가 붙어있고 다양한 라이브러리 사용, 이런 것들이 유기적으로 잘 작동하는지 테스트

- supertest 패키지: auth.js의 라우터 테스트(app 객체를 모듈로 만들어 분리)
- sever.js = app 포트 리스닝만 담당

**[auth.test.js]**

1. beforeAll 함수: 테스트를 실행하기 전에 수행되는 코드, sequelize.sync() 넣어 db에 테이블 생성

   = afterAll(모든 테스트가 끝난 후), beforeEach(각각의 테스트 수행 전), afterEach(각각의 테스트 수행 후) ⇒ 테스트를 위한 값이나 외부 환경을 설정할 때 테스트 전후로 수행할 수 있도록 사용하는 함수

2. supertest 패키지로부터 request 함수 불러와 → app 객체를 인수, 메서드로 원하는 라우터에 요청 보낼 수 있음
   1. 데이터 = send 메서드에 담아서 보냄
   2. 예쌍되는 응답 결과를 expect 메서드의 인수로 제공하면 그 값이 일치하는지 확인
   3. supertest 사용 시 app.listen 수행x하고도 서버 라우터 실행 가능

→ 통합 테스트할 때에는 모킹 최소한이 좋지만 직접적인 테스트 대상이 아닌 경우에는 모킹 가능

1. 첫 번째 describe ⇒ 회원가입 테스트
2. 두 번째 describe ⇒ 로그인한 상태에서 회원가입을 시도하는 경우(코드 순서 중요!), 로그인한 상태여야 회원가입을 테스트할 수 있어 로그인 후 회원가입 요청이 순서대로 이루어져야 ⇒ 이때 agent 만들어서 하나 이상의 요청에서 재사용 가능
3. beforeEach ⇒ 각각의 테스트 실행에 앞서 먼저 실행되는 부분, 회원가입 테스트를 위해 생성해둔 agent 객체로 로그인 먼저 수행
4. 로그인된 agent 객체로 회원가입 테스트 진행

→ 이전에 성공했던 테스트를 다시 수행하면 실패 why?

: 이전 테스트에서 이미 계정을 생성해서, 테스트 종료 시 데이터를 정리하는 코드 추가

### 11.5 부하 테스트

- 코드에 문법적, 논리적 문제가 없어도 서버의 하드웨어 제약 때문에 서비스가 중단될 수 있음 ex) OOM
- 서버는 접속자들의 정보를 저장하기 위해 각각의 접속자마다 일정한 메모리 할당 ⇒ 사용하는 메모리의 양이 증가하다가 서버의 메모리 용량을 넘어서면 문제 발생

⇒ 부하 테스트를 통해 예측 가능: artillery

> npx artillery quick —count 100 -n 50 [http://localhost:8001](http://localhost:8001): 빠르게 부하 테스트를 하는 방법

- --count 옵션: 가상의 사용자 수
- -n 옵션: 요청 횟수
- 하나의 요청이 얼마나 많은 작업을 하는지가 중요
- Request latency(응답 지연 속도) 주목해서 보기
- median과 p95의 차이는 크지 않으면 좋음 → 수치 차이가 적을 수록 대부분의 요청이 비슷한 속도로 처리 되었다는 의미
- Scenarios counts = 총 사용자 수
- Codes = HTTP 상태 코드

**[loadtest.json]**

config 객체: target을 현재 서버, phases에서 60초동안 매초 30명의 사용자를 생성하도록

scenarios: 가상 사용자들이 어떤 동작 할ㄹ지

1. 첫 번째 flow: 먼저 메인 페이지 → 로그인 → 해시태그 검색: 로그인할 때 요청의 본문으로 email과 pw를 JSON 형식으로 보냄
2. 두 번째 flow: 첫 번째 flow와는 다른 일련의 과정을 시뮬레이션하고 싶다면...

⇒ 요청-응답 시 db에 접근할 때 가장 많은 시간 소요, 서버는 여러 대로 늘리기 쉽지만 db는 그렇지 않아 하나의 db에 많은 요청이 몰려, 즉! db에 접근하는 요청을 최대한 줄이는 것이 좋음

⇒ arrivalRate를 줄이거나 늘려서 자신의 서버가 어느 정도의 요청을 수용할 수 있는지 체크해보는 것이 좋음 + 한 번만 테스트하는 게 아니라 여러 번 같은 설정값으로 테스트하여 평균치를 내보는 것이 좋음

### 11.6 프로젝트 마무리하기

- 테스트를 작성한다고 해서 에러 발생 x는 아님
- 테스트를 올바르게 작성하지 않으면 하지 않는 것보다 못한 상황 발생
- 테스트 작성하면 긍정적인 영향과 테스트하는데 필요한 공수를 함께 고려해서 테스트할 범위 지정
- 실제 서비스에서 모든 기능 테스트하기 어려워 우선순위를 정하여 높은 기능 위주로 테스트
- 테스트 커버리지 = 100% ≠ 에러 발생하지 않는 것

---
