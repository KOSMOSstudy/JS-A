# 8주차 JS 스터디 정리

| 장   | 제목               |
| ---- | ------------------ |
| 10장 | 웹 API 서버 만들기 |

## 10장

### 10.1 API 서버 이해하기

api: application programming interface의 약어, 다른 어플리케이션에서 현재 프로그램의 기능을 사용할 수 있게 용하는 접점

웹 api: 다른 웹 서비스의 기능을 사용하거나 자원을 가져올 수 있는 창구

api → '열었다' or '만들었다': 다른 프로그램에서 현재 기능을 사용할 수 있게 허용했음

: 다른 사람에게 정보 제공하고 싶은 부분만 열기

: 인증된 사람만 일정 횟수 내에서 가져가게 제한 두는 등

⇒ 웹 api 서버: 같은 서버에 api를 올려서 url을 통해 접근할 수 있게 만든 것

\*크롤링: 웹 사이트가 자체적으로 제공하는 api가 없거나 api 이용에 제한이 있을 때 사용하는 방법으로 표면적으로 보이는 웹 사이트의 정보를 일정 주기로 수집 후 자체적으로 가공하는 기술

### 10.2 프로젝트 구조 갖추기

- NodeBird 서비스와 데이터베이스 공유

다른 서비스에 NodeBird 서비스의 게시글, 해시태그, 사용자 정보 → json 형식으로 제공(인증 받은 사용자에게만 일정한 할당량 내에서 api 호출할 수 있도록..)

**[app.js]**

포트 번호를 8002로 하여 NodeBird(8001)와 함께 실행 가능

도메인을 등록하는 기능: 도메인 모델을 추가

\*도메인: 인터넷 주소

도메인 모델 → 시퀄라이즈에 연결(↔ 사용자 모델과 일대다 관계: 사용자 한 명이 여러 도메인 소유 가능)

- 인터넷 주소(host)
- 도메인 종류(type): ENUM 속성 - 넣을 수 있는 값을 제한하는 데이터 형식
- 클라이언트 비밀 키(clientSecret): 다른 개발자들이 NodeBird의 api 사용할 때 필요한 비밀 키 → 유출 시 다른 사람을 사칭해서 요청 보낼 수도 있음, 안전 장치로서 요청을 보낸 도메인까지 일치해야 요청을 보낼 수 있게 제한을 둘 것, UUID 속성 - 충돌 가능성이 매우 적은 랜덤 문자열

**[index.js]**

GET / 라우터: 접속 시 로그인 화면

도메인 등록 라우터: 폼으로부터 온 데이터를 도메인 모델에 저장, clientSecret 값을 uuid 패키지를 통해 생성 ⇒ 36자리 문자열 형식

ex)1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed

- 세 번째 마디의 첫 번째 숫자 4: 버전
- const { v4 : uuidv4 } → 패키지의 변수나 함수를 불러올 때 이름 바꿀 수 있음

도메인 등록 이유? 등록한 도메인에서만 api 사용할 수 있게 하기 위해서

- 웹 브라우저에서 요청 보낼 때 응답하는 곳과 도메인이 다르면 CORS 에러 발생

\*CORS? 브라우저가 현재 웹 사이트에서 함부로 다른 서버에 접근하는 것을 막는 조치

- CORS 문제 해결하려면 api 서버 쪽에서 미리 허용할 도메인을 등록해야함
- 서버 → 서버로 요청 보내는 경우 문제 발생 x
- CORS는 브라우저에서 발생하는 에러

ex) [localhost:4000](http://localhost:4000) 도메인 등록(NodeBird api를 사용할 도메인 주소 → 다른 개발자들이 만든 서버), 발급받은 비밀 키는 localhost:4000에서 NodeBird api를 호출할 때 인증 용도로 사용 가능

### 10.3 JWT 토큰으로 인증하기

JWT: json web token의 약어, json 형식의 데이터를 저장하는 토큰

- 헤더: 토큰의 종류와 해시 알고리즘 정보가 들어있음
- 페이로드: 토큰의 내용물이 인코딩된 부분
- 시그니처: 일련의 문자열, 토큰이 변조되었는지 여부를 확인 가능, JWT 비밀 키로 만들어짐

내용이 노출되는 토큰을 사용하는 이유? 내용이 들어있기 때문, 내용이 없는 랜덤한 토큰이면 토큰의 주인이 누구인지 그 사람의 권한은 무엇인지 매 요청마다 확인해야함 ⇒ 보통은 데이터베이스를 조회해야 하는 복잡한 작업인 경우가 많음

장점: JWT 비밀 키를 알지 않는 이상 변조 불가 → 변조한 토큰은 시그니처를 비밀 키를 통해 검사할 때 들통남

단점: 용량이 큼, 매 요청 시 토큰이 오고 가서 데이터양 증가

**[middleware.js]**

- 요청 헤더에 저장된 토큰 사용
- 사용자가 쿠키처럼 헤더에 토큰을 넣어 보냄
- jwt.verify(토큰, 토큰의 비밀 키): 토큰 검증
- 토큰의 비밀 키 일치X → 인증 받을 수 X or 올바른 토큰 but 유효 기간 지난 경우: 에러 발생하여 catch문으로 이동, 유효 기간 지난 경우 419 상태 코드로 응답

↔ 인증 성공한 경우: 토큰의 내용이 반환되어 req.decoded에 저장, 내용: 사용자 아이디, 닉네임, 발급자, 유효 기간

**[v1.js]**

라우터의 이름: v1(버전 1)

라우터에 버전을 붙인 이유? 한 번 버전이 정해진 후에는 라우터를 함부로 수정하면 안되기 때문, 다른 사람이나 서비스가 기존 api를 쓰고 있음! api 서버 코드를 바꾸면 사용 중인 다른 사람에게 영향을 미칠 수 있음

POST /v1/token 라우터: 전달받은 클라이언트 비밀 키로 도메인이 등록된 것인지 먼저 확인

- 등록되지 x : 에러 메세지로 응답
- 등록: 토큰 발급해서 응답
- jwt.sign(토큰의 내용, 토큰의 비밀 키, 토큰의 설정): 토큰 발급

→ 만료 시 토큰 재발급

GET /v1/test 라우터: 사용자가 발급받은 토큰을 테스트해볼 수 있는 라우터, 토큰을 검증하는 미들웨어를 거친 후 검증 성공 시 토큰의 내용물을 응답으로 보냄

⇒ 라우터의 응답: JSON 형태에 code, message 속성 존재 + 토큰이 있는 경우 token 속성 → 일정한 형태여야 응답받는 쪽에서 처리하기 좋음

### 10.4 다른 서비스에서 호출하기

api를 사용하는 서비스: 다른 서버에게 요청을 보내므로 클라이언트 역할

api 사용자의 입장: NodeBird 앱의 데이터를 가져오고 싶어 하는 사용자

**[index.js]**

GET /test 라우터: NodeCat 서비스가 토큰 인증 과정을 테스트해보는 라우터

- 요청이 왔을 때 세션에 발급받은 토큰이 저장되어 있지 않다면, POST [http://localhost:8002/v1/token](http://localhost:8002/v1/token) 라우터로부터 토큰 발급, HTTP 요청의 본문에 클라이언트 비밀 키 실어보냄
- 발급 성공 시 발급 받은 토큰으로 다시 GET [http://localhost:8002/v1/test](http://localhost:8002/v1/test)에 접근하여 토큰이 유효한지 테스트
- JWT 토큰을 요청 본문 대신 authorization 헤더에 넣음

### 10.5 SNS API 서버 만들기

**[v1.js]**

GET /posts/my 라우터 & GET /posts/hashtag/:title 라우터: 내가 올린 포스트와 해시태그 검색 결과를 가져오는 라우터, 사용자에게 제공해도 되는 정보를 api로 만듦

**[index.js]**

request 함수: NodeBird API에 요청을 보내는 함수, 자주 재사용되기 때문에 분리

- 요청 헤더 origin 값 - localost:4000 설정: 어디서 요청을 보내는지 파악, 주소가 바뀌면 나중에 바뀜
- 세션에 토큰이 없으면 clientSecret 사용해 토큰 발급 받는 요청 보내고 발급 받은 후 토큰을 이용하여 api 요청 + 토큰 재사용 위해 세션에 저장
- 토큰 만료 시 419 에러: request 함수 재귀적으로 호출하여 다시 요청

GET /mypost 라우터: api를 사용하여 자신이 작성한 포스트를 json 형식으로 가져오는 라우터

GET /search/:hashtag 라우터: api 사용하여 해시태그를 검색하는 라우터

### 10.6 사용량 제한 구현하기

: 일정 기간 내에 api를 사용할 수 있는 횟수를 제한하여 서버의 트래픽을 줄이는 것이 좋음

**[middleware.js]**

라우터에 apiLimiter 넣으면 라우터에 사용량 제한 걸림

- 옵션: windowMS(기준 시간), max(허용 횟수), handler(제한 초과 시 콜백 함수) 등
- deprecated 미들웨어: 사용하면 안되는 라우터에 붙임(410 코드와 함께 새로운 버전을 사용하라는 메세지 응답)

<api 응답 목록>

1. 200: json 데이터
2. 401: 유효하지 않은 토큰
3. 410: 새로운 버전이 나왔음
4. 419: 토큰 만료
5. 429: 1분에 한 번만 요청 가능
6. 500~: 기타 서버 에러

**[v2.js]**

- 토큰 유효 기간: 30분으로 늘림
- 사용량 제한 미들웨어 추가
- 기존 v1 라우터 사용 시 경고 메세지

**[v1.js]**

- 라우터 앞에 deprecated 미들웨어 추가 → v1으로 접근한 모든 요청에 deprecated 응답

### 10.7 CORS 이해하기

**[index.js]**

clientSecret의 {{key}} 부분: 넌적스에 의해 실제 키로 치환돼서 렌더링, 실제 서비스에서는 서버에서 사용하는 비밀 키와 프론트에서 사용하는 비밀 키 따로 두는 것이 좋음!

- 서버에서 사용하는 비밀 키가 더 강력하기 때문
- 프론트에서 사용하는 비밀 키는 모든 사람에게 노출됨

오류 내용: Access-Control-Allow-Origin 헤더가 없다.

→ 브라우저와 서버의 도메인이 일치하지 않으면 기본적으로 요청 차단 (브라우저 → 서버로 요청을 보낼 때만 발생, 서버 → 서버로 요청 보낼 때는 발생X)

⇒ CORS 문제

Network 탭: Method가 POST 대신 OPTIONS(실제 요청 보내기 전 서버가 이 도메인을 혀용하는지 체크하는 역할)로 표시

→ 해결하려면? 응답 헤더에 Access-Control-Allow-Origin 헤더 넣기: 클라이언트 도메인 요청을 허락하겠다는 뜻(cors 패키지)

- Access-Control-Allow-Origin가 \*인 경우? 모든 클라이언트의 요청을 허용
- credectials: true - Access-Control-Allow-Origin 헤더를 true ⇒ 새로운 문제 발생
- 요청을 보내는 주체가 클라이언트라서 비밀 키가 모두에게 노출
- 처음에 비밀 키 발급 시 허용한 도메인을 적게 → 호스트와 비밀 키가 모두 일치할 때만 CORS를 허용하게 수정

**[v2.js]**

- 도메인 모델로 클라이언트의 도메인과 호스트가 일치하는 것이 있는지 검사(http나 https 같은 프로토콜을 떼어낼 때는 url.parse 사용)
- 일치하는 것이 없다면 CORS 없이 next 호출
- cors 미들웨어에 옵션 인수 → origin 속성에 허용할 도메인만 따로 적음, 여러 개의 도메인을 허용하려면 배열 사용

### 10.8 프로젝트 마무리해보기

- api: 다른 애플리케이션의 기능을 사용할 수 있게 해주는 창구
- 모바일 서버 구성할 때 서버: rest api 방식
- api 사용자가 api를 쉽게 사용할 수 있도록 사용 방법, 요청 형식, 응답 내용에 관한 문서 준비
- jwt 토큰의 내용: 공개, 변조될 수 있음 (시그니처 확인 시 변조 여부 확인 가능)
- 토큰 사용하여 api 오남용 방지
- route.use 활용하여 라우터 간 공통되는 로직 처리
- cors나 passport.authenticate 처럼 미들웨어 내에서 미들웨서 실행 가능
- CORS: 브라우저와 서버의 도메인이 다르면 요청이 거절ehl는 특성, 서버와 서버 간의 요청에서는 발생X

---
